[{"title":"Hello World","date":"2022-02-19T03:04:28.000Z","path":"2022/02/19/hello-world/","text":"Welcome to Hexo! This is your very first post.Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"防抖和节流","date":"2020-12-01T06:16:25.000Z","path":"2020/12/01/防抖和节流/","text":"1.防抖防抖：在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时；连续的事件，只需触发一次回调； 使用场景有： 1.搜索框输入，只需用户最后一次输入完，再发送请求；2.窗口resize，只需窗口调整完成后，计算窗口大小，防止重新渲染； 2.节流节流：限制函数在一段时间内只执行一次；每间隔一段时间执行一次回调； 高频点击提交，表单重复提交 谷歌搜索，搜索联想功能 滚动加载，加载更多或滚动到底部监听","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"数组去重方法","date":"2020-11-19T12:37:37.000Z","path":"2020/11/19/数组去重方法/","text":"https://github.com/loonmucy/js-basic-code/blob/main/array_distinct.js","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"http协议整理","date":"2020-11-18T14:05:11.000Z","path":"2020/11/18/http协议整理/","text":"1. HTTP协议定义 HTTP是超文本传输协议，客户端与服务器端请求与应答的标准 HTTP协议是基于TCP协议实现的，TCP是面向连接的 HTTP是不保存状态的协议，协议对于发送过的请求或响应不做持久化处理；客户端每次发送请求时，会带上本次请求所需的所有信息 HTTP&#x2F;0.9 -&gt; 1990HTTP&#x2F;1.0 -&gt; 1996HTTP&#x2F;1.1 -&gt; 1997 -&gt; 广泛使用的版本HTTP&#x2F;2 -&gt; 2015","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"vue整理","date":"2020-09-01T05:18:15.000Z","path":"2020/09/01/vue整理/","text":"1. vue 简介 vue是一个专注于构建web用户界面的javascript库，它易用、灵活、速度快，提供许多功能和可选工具，从而使开发者能快速构建一个web应用，是一个渐进式框架，遵循渐进增量的设计原则；vue既可以构建小的原型，又可以构建复杂的大型web应用 vue整体上遵循MVVM（Model-View-ViewModel，模型-视图-视图模型）架构，即是说在Vue中，View（用户界面或视图）跟Model（数据）是独立的，ViewModel是View和Model交互的桥梁； MVVM架构中，View和Model没有直接联系，通过ViewModel交互，View、Model和ViewModel的交互是双向的，View视图的变化会同步到Model中，而Model数据的变化也会立即反应到View上； ViewModel通过双向数据绑定把View层和Model层连接起来，View和Model之间的同步工作是自动的，无需人为干预，因此开发者只需关注业务逻辑，不需要手动操作DOM，也不需要关注数据的状态同步问题，数据的状态维护由MVVM统一管理; vue的核心功能有： 一个响应式的数据系统，通过轻量级的虚拟dom引擎和最少的优化工作来自动更新用户界面； 灵活的视图声明，包括优雅友好的HTML模板、JSX（在JavaScript中编写HTML的技术）以及hyperscript渲染函数（完全使用Javascript） 由可维护、可复用组件构成的组件化用户界面 官方的组件库提供了路由、状态管理、脚手架以及更多高级功能，使Vue成为一个灵活且功能完善的前端框架 2. Vue生命周期 Vue实例从创建到销毁的过程，就是生命周期；从开始创建、初始化数据、编译模版、挂载Dom-&gt;渲染、更新-&gt;渲染、销毁等一系列过程，称为Vue的生命周期 Vue生命周期中有多个事件钩子，让开发者在控制Vue实例的过程中更容易形成好的逻辑 Vue生命周期总共有8个阶段：创建前&#x2F;后，载入前&#x2F;后，更新前&#x2F;后，销毁前&#x2F;后；对应的事件钩子为beforeCreate、created、beforeMount、mounted、beforeUpdate、updated、beforeDestroy、destroyed 第一次加载页面会触发beforeCreate、created、beforeMount、mounted这4个钩子 Dom渲染在mounted中完成 3. Vue双向绑定原理：Object.defineProperty()vue实现数据双向绑定是采用数据劫持和发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter、getter，在数据变化时发布消息给订阅者，触发响应回调；当把一个普通的JavaScript对象传给Vue实例来作为它的data选项时，Vue将遍历它的属性，用Object.defineProperty将它们转为getter&#x2F;setter，用户看不到getter&#x2F;setter，但是在内部它们让Vue追踪依赖，在属性被访问和修改时通知变化 4. Vue组件间的数据传递 父组件与子组件传值 父组件传给子组件：子组件通过props接受数据 子组件传给父组件：$emit方法 非父子组件即兄弟组件间传值事件总线eventBus，项目比较小时，比较合适；创建一个事件中心，相当于中转站，用它来传递和接收事件 5. vuex只用来读取的状态应放在store中；改变状态的方式是提交mutations，这是同步的事件；异步的逻辑应该封装在action中 state Vuex使用单一状态树，即每个应用仅包含一个store实例，存放数据状态，不可以直接修改里面的数据；单一状态树与模块化并不冲突 mutations mutations定义的方法动态修改Vuex的store中的状态或数据 getters 类似vue的计算属性，主要用来过滤一些数据 action 异步操作数据；将mutations里处理数据的方法变成可异步的处理数据的方法；view层通过store.dispath来分发action 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state) &#123; state.count++ &#125; &#125;, actions: &#123; increment(context) &#123; context.commit(&#x27;increment) &#125; &#125;,&#125;) 6. keep-alivekeep-alive是Vue内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 7. vue中key值的作用当用v-for更新已渲染过的元素列表时，默认’就地复用‘策略；如果数据项的顺序发生变化，vue不会移动dom元素来匹配数据项的顺序，而是简单复用每个元素，并且确保它在特定索引下显示已被渲染过的每个元素；key的作用就是为了高效的更新虚拟dom","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://saltlike.github.io/tags/vue/"},{"name":"面试","slug":"面试","permalink":"https://saltlike.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"前端面试题整理","date":"2020-08-22T03:06:46.000Z","path":"2020/08/22/前端面试题整理/","text":"1、防抖和节流防抖防止抖动，单位时间内事件触发会被重置，以免把一次事件误认为多次，代码实现重在清零clearTimeout(timer)防抖场景 登录、发短信等按钮为避免用户点击太快，以至发送多次请求 调整浏览器窗口大小，resize次数过于频繁，此时需要一次到位 节流 控制流量，单位时间内事件只能触发一次，控制事件发生的频率，代码实现重在加锁关锁timer=timeout;timer=null节流场景 scroll事件，每隔一秒计算一次位置信息 浏览器播放事件，每隔一秒计算一次进度信息 input框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求（也可做防抖） 2、全部替换一个子串为另一个子串 js巧妙替换法：str.split(&#39;foo&#39;).join(&#39;bar&#39;)12&gt; &#x27;hello. hello. hello. &#x27;.split(&#x27;hello. &#x27;).join(&#x27;A&#x27;)&lt; &quot;AAA&quot; 正则表达式替换（如果有特殊字符，就会出问题）123// 期待结果: &#x27;AhelloX hello3 &#x27;&gt; &#x27;hello. helloX hello3 &#x27;.replace(new RegExp(&#x27;hello. &#x27;, &#x27;g&#x27;), &#x27;A&#x27;)&lt; &quot;AAA&quot; 3、css盒模型盒模型的组成，由里向外：content、padding、border、marginIE盒模型中，width表示content+padding+border这三部分的宽度标准盒模型中，width表示content部分的宽度css3中box-sizing的使用： 12box-sizing: content-box（默认属性） W3C标准盒模型box-sizing: border-box IE盒模型 4、1rem、1em、1vh、1px代表的含义rem rem是全部的长度都相对于根元素&lt;html&gt;元素，通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就是rem em 子元素字体大小的em是相对于父元素字体大小 元素的width、height、padding、margin用em就是相对于该元素的font-size而言 vw&#x2F;vh 全称是viewport width和viewport height，视窗的宽度和高度；相当于屏幕宽度和高度的1%，另外，处理宽度用%单位更合适，处理高度用vh单位更好 px 像素（pixel），相对长度单位。像素px是相对于显示器屏幕分辨率而言的例如：电脑分辨率为1920*1024，前者表示屏幕宽度总共有1920个像素，后者表示高度为1024个像素 5、&lt;label&gt;标签的作用方便鼠标点击使用，扩大可点击的范围，增强用户体验 6、遍历A节点的父节点下的所有子节点1234&lt;script&gt; var b = document.getElementById(&#x27;a&#x27;).parentNode.children console.log(b)&lt;/script&gt; 7、用js递归方式写1到5的求和1234567891011&lt;script&gt; function add (n1,n2) &#123; let total = n1 + n2 if(n2 + 1 &gt; 5) &#123; return total &#125;else &#123; return add(total,n2 + 1) &#125; &#125; document.write(add(1,2))&lt;/script&gt; 8、从在浏览器中输入网址，到html渲染的过程 在地址栏输入地址后，会经过DNS域名解析查询到要请求的服务器的地址。然后经过TCP连接到服务器。服务器返回浏览器请求的内容，html源码 浏览器解析html源码，创建DOM树；并行请求css&#x2F;image&#x2F;js的内容；每一个html标签、文本对应一个节点，dom树的根结点对应的是html标签 浏览器解析css代码，构建渲染树。css代码中的非法语法会被直接忽略 dom树跟html标签一一对应，渲染树会忽略不需要渲染的元素，比如：head、display：none的元素 渲染树创建好后，浏览器就把页面绘制到屏幕上以上过程不是一次性顺序完成的，css和javascript往往会多次修改dom和css，所以以上过程会被重复执行 9、中断ajax请求 设置超时时间让ajax自动断开 手动中止ajax请求，ajax.abort() 10、事件代理事件委托是指将事件绑定到目标元素的父元素上，利用冒泡机制触发该事件 11、js继承方式构造函数继承、原型继承、组合继承 12、数组去重 数组遍历去重 es6方法：arr = [...new Set(arr)] ; Array.from()能把set结构转换为数组：arr = Array.from(new Set(array)); 13、get、post的区别 get传参是通过地址栏url传递，可以直接看到get传递的参数，请求数据在url后通过？连接，&amp;进行参数分割；post传参在url中不可见，传递参数在http的请求体内； get传递的数据大小受url大小的限制，url最大长度是2048个字符；post传参没有长度限制 get后退不会有影响，post后退会重新进行提交 get请求可以被缓存，post请求不可以被缓存 get请求只支持url编码，post支持多种编码方式 get只支持ASCII字符，post没有字符类型限制 get请求的记录会留在历史记录中，post请求不会留在历史记录中 14、http响应码及含义 1** 临时响应100：请求者应继续提出请求101: 切换协议，请求者已要求服务器切换协议，服务器已确认并准备进行切换 2** 成功200: 正确的请求返回正确的结果201: 表示资源被正确的创建；例如：我们post用户名、密码正确创建一个用户就可以返回201202:请求是正确的，但结果正在处理中，这时客户端可以通过轮询等机制继续请求 3** 已重定向300: 请求成功，但结果有多种选择301: 请求成功，但资源被永久转移303: 使用get访问新的地址来获取资源304: 请求的资源没有被修改过 4** 请求错误400: 请求出现错误，例如：请求头不对等401: 没有提供认证信息，请求的时候没有带上token等402: 为以后需要所保留的状态码403: 请求的资源不允许访问，也就是没有权限404: 请求的内容不存在 5** 服务器错误500: 服务器错误501: 请求还没有被实现 15、JavaScript数据类型 基本数据类型：number、String、Boolean、undefined、null、symbol（es6新增的数据类型） 引用数据类型：array、function、object（统称为object） 16、数据类型检测 对于基本数据类型，除了null，typeof都可以显示正确的类型 对于对象，array、object会返回object，function返回functiontypeof null //objecttypeof NaN //numbertypeof console.log //function Object.prototype.toString.call()可以检测所有数据类型 instanceOf通过原型链判断数据类型 17、深浅拷贝 浅拷贝Object.assign() 会合并对象生成一个新对象；如果对象的属性是普通类型，改变后新对象不会改变；如果是引用类型，改变后新对象会改变； 深拷贝JSON.parse(JSON.stringfy(obj))利用JSON.stringfy(obj)先将对象转为json字符串，再用JSON.parse()转回json对象可以实现深拷贝js实现深拷贝分两步：浅拷贝 + 递归，浅拷贝时判断属性值是否是对象，如果是对象进行递归操作1234567891011121314151617function cloneDeep(source) &#123; if (!isObject(source)) return source; // 非对象返回自身 var target = Array.isArray(source) ? [] : &#123;&#125;; for (var key in source) &#123; if (source.hasOwnProperty(i)) &#123; if (isObject(source[key])) &#123; target[key] = cloneDeep(source[key]); // 注意这里 &#125; else &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125; function isObject(obj) &#123; return typeof obj === &#x27;object&#x27; &amp;&amp; obj != null; &#125; 18、new操作符具体做了什么 首先创建实例对象{} this变量引用该对象，同时继承构造函数的原型 属性和方法被加入到this引用的对象中 新创建的对象由this所引用，最后隐式的返回this 19、在浏览器中输入一个网址后，发生了什么 浏览器通过DNS查找该域名的IP地址 浏览器根据解析得到的IP地址向web服务器发送一个http请求 服务器收到请求并进行处理 服务器返回一个响应 浏览器对该响应进行解码，解析html为dom，css为css-tree，dom + css生成render-tree绘图 页面显示完成后，浏览器发送异步请求 整个过程结束后，浏览器关闭tcp连接 20. promisepromise是异步编程的解决方案，比传统的callback更优雅，es6将其写进语音标准，原生提供了promise对象 21. 浏览器兼容问题由于浏览器内核的差异，以及html、css的发展，会出现兼容性问题 不同浏览器的默认样式存在差异，可以统一设置css初始化样式抹平差异，最简单的情况：不同浏览器的标签默认margin、padding差异较大，通过设置*&#123;margin:0;padding:0&#125;解决 Firefox、Chrome不兼容cursor：hand；解决：cousor：pointer兼容所有浏览器 IE6中元素浮动后margin值变双倍解决：将元素转为行内属性；display: inline css的hack问题，主要针对IE的不同版本，不同的浏览器写法不同，条件注释hackIE6认识的hacker是下划线_和星号* #id&#123;_display:block;&#125;IE7遨游认识的hacker是星号* #id&#123;*display:block&#125;ID8的css Hack写法是在css属性后分号前加空格、斜线、和9 #id&#123;display:block /9&#125;火狐的hack写法@-moz-document url-prefix（）{ #id{ display: block; } } 盒模型的不同：IE盒模型和标准盒模型 javascript的兼容性，最好是应用jquery库，该库对兼容性都做了处理 标准的事件绑定方法是addEventListener，但IE下是attachEvent 事件捕获方式不同，标准浏览器是由外至内，IE是由内到外（事件冒泡）。但最后是将IE的定为标准 获取目标元素的方法不同，标准浏览器是event.target,IE下是event.srcElement ajax的实现方式不同，标准浏览器是XMLHttpRequest,IE下是activeXObject 要减少浏览器兼容性问题，通常采用一些现成的UI技术ext、flex或其他的UI框架，这些技术已经有相当好的浏览器兼容性了；另外采用js框架做辅助，如jQuery等对dom、事件、ajax的兼容，和页面上的hack技术 22. http与https的区别 传输信息安全性不同 http协议：超文本传输协议，信息是明文传输。如果攻击者截取了web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息；是专门用来传输注入html的超媒体文档等web内容的协议，它是基于传输层tcp协议的应用层协议； https协议：是基于安全套接字的http协议，是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全； 连接方式不同 http协议：http的连接很简单，是无状态的； https协议：是由ssl+http协议构建的可进行加密传输、身份认证的网络协议； 端口不同 http协议：使用的端口是80； https协议：使用的端口是443； 证书申请方式不同 http协议：免费申请 https协议：需要到ca申请证书，一般免费证书很少，要交费 https优点： 使用https协议可认证用户和服务器，确保数据发送到正确的客户机和服务器 https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性 https是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本 https缺点： 握手阶段比较耗时，使页面加载时间延长，增加耗电 SSL证书需要钱，功能越强大证书费用越高，个人网址、小网站没有必要一般不会用 加密范围有限，在黑客攻击、拒绝服务攻击、服务器劫持方面几乎不起作用。而且SSL证书的信用链体系并不安全 https连接缓存不如http高效，会增加数据开销和功耗 SSL证书通常要绑定IP，不能在同一ip上绑定多个域名，IPV4资源不能支撑这个消耗如何将网站从http切换到https？ 将页面中的所有链接，如js、css、图片等链接由http改为https 建议保留http，以便在切换时做http和https的兼容；具体方式是，去掉链接中的http头部，以便自动匹配http头和https头；例如：将http://www.baidu.com改为//www.baidu.com,然后当用户从http的入口进入时，页面就是http，从https进入页面，页面即是https 23. CDN加速原理CND,内容分发网络，将静态资源缓存到离用户很近的一个CDN节点上，就不用去访问距离远的服务器，这样不仅能提高用户的访问速度，也能减少服务器的带宽消耗，降低负载；当请求到达CDN节点后，节点判断自己的内容缓存是否有效，如果有效，就立即发送响应内容给用户，从而加快响应速度。如果CDN节点的缓存失败，它会根据配置去源服务器获取最新的资源，然后发送给用户，并且会将内容缓存下来给后续访问的用户；这就意味着一个地区的用户只需要访问一次服务器，后续的用户都能因此受益； 服务商提供智能域名解析服务，当浏览器发起域名查询时，这种智能DNS服务会根据用户IP寻找离它最近的CDN节点 CDN多用于图片、js文件、css文件、静态页面等静态资源，不适用于动态页面 24. JavaScript同步异步JavaScript的单线程是指在JS引擎中负责解释和执行Javascript代码的线程只有一个，即是：同一时间只能做一件事；这是因为JavaScript的主要用途是与用户互动，以及操作DOM，这决了它只能是单线程，否则会带来复杂的同步问题；例如：如果JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准 JavaScript中如果不存在异步，只能自上而下的执行，万一上一行解析时间很长，那么下面的代码就会被阻塞，对用户而言，阻塞就意味着“卡死”，这样就导致很差的用户体验；同步可以保证顺序一致，但容易导致阻塞；异步可以解决阻塞问题，但会改变顺序性； 为了利用多核cpu的计算能力，html5提出web worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作dom，所以，这个标准并没有改变JavaScript单线程的本质 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。于是，任务队列就产生了； 由于IO设备（输入输出设备）很慢，这时候cpu就处于空闲状态，不得不等着结果出来，再往下执行；但是，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再把挂起的任务执行下去； 所有任务分两种，同步任务和异步任务；同步任务指，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指，不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，并且主线程空闲，该任务才会进入主线程执行 异步执行的运行机制如下 所有同步任务都在主线程上执行，形成一个执行栈 主线程之外，还有一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件 一旦主线程执行栈中的所有同步任务执行完毕，系统就会读取任务队列，那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行 主线程不断重复上面三步 任务队列是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。有时存在定时器功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程； 任务队列中的事件，需要指定回调函数。回调函数就是那些会被主线程挂起来的代码；异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数 25. MVC和MVVM MVC就是model-view-controller，它是在不改变视图的情况下，对用户的输入进行响应；用户对view的操作交给controller处理，在controller中响应view的事件，并调用model的接口对数据进行操作，一旦model发生变化便通知相关视图进行更新 缺点是： 所有业务逻辑都在controller里操作，逻辑复杂不利于维护 大量dom操作使页面渲染性能降低，加载速度变慢，影响用户体验 当model频繁变化时，要主动更新view；当用户操作导致model变化，同样要将变化的数据同步到model，导致工作繁琐，且难以维护复杂多变的数据状态； MVVMMVVM实现了view和model的自动同步，当model的属性改变时，我们不用再手动操作dom，来改变view的显示，该属性对应的view会自动改变，ViewModel的核心是Vue中的双向数据绑定 通过数据绑定实现model转化成view 通过DOM事件监听将view转化成modelViewModel的存在在于抽离Controller中展示的业务逻辑，而不是替代controller，其他视图操作业务还是应该放在controller中实现；MVVM实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"面试","slug":"面试","permalink":"https://saltlike.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"bat脚本批量启动应用程序 ","date":"2020-06-27T13:52:50.000Z","path":"2020/06/27/bat脚本批量启动应用程序/","text":"在windows上利用自动化脚本批量启动应用程序注意：路径里不要有中文 有空格的情况 12345start &quot;&quot; &quot;D:\\Program Files\\Foxmail 7.2\\Foxmail.exe&quot;REM start &quot;&quot; &quot;C:\\Program Files (x86)\\Yinxiang Biji\\印象笔记\\Evernote.exe&quot;start &quot;&quot; &quot;C:\\Users\\Public\\Desktop\\Evernote&quot;start &quot;&quot; &quot;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&quot;start &quot;&quot; &quot;D:\\VSCode\\Microsoft VS Code\\Code.exe&quot; 无空格的情况 12start D:\\Program Files\\Foxmail 7.2\\Foxmail.exe","tags":[{"name":"工具","slug":"工具","permalink":"https://saltlike.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Element UI动态表格功能","date":"2020-06-21T10:47:17.000Z","path":"2020/06/21/Element-UI动态表格功能/","text":"Element UI动态表格功能123&lt;el-table ref=&quot;detailTable&quot; class=&quot;atb-table&quot; border size=&quot;mini&quot; :data=&quot;dataList&quot; v-loading=&quot;loading&quot; height=&quot;100%&quot; style=&quot;width: 100%&quot;&gt; &lt;el-table-column v-for=&quot;(item,index) in itemList&quot; :key=&quot;index&quot; :prop=&quot;item.prop&quot; :label=&quot;item.label&quot;&gt;&lt;/el-table-column&gt;&lt;/el-table&gt; 接口数据格式1234567891011121314151617181920212223&#123; &quot;code&quot;: 0, &quot;msg&quot;: &quot;success&quot;, &quot;data&quot;: &#123; &quot;head&quot;: [ &quot;第一列&quot;, &quot;第二列&quot;, &quot;第三列&quot; ], &quot;body&quot;: [ [ &quot;第一行&quot;, 11, 12 ], [ &quot;第二行&quot;, 21, 22 ] ] &#125;&#125; 需要把数据格式整理成下面的结构123456789itemList: [ &#123;&#x27;prop&#x27;:&#x27;prop0&#x27;,&#x27;label&#x27;:&#x27;第一列&#x27;&#125;, &#123;&#x27;prop&#x27;:&#x27;prop1&#x27;,&#x27;label&#x27;:&#x27;第二列&#x27;&#125;, &#123;&#x27;prop&#x27;:&#x27;prop2&#x27;,&#x27;label&#x27;:&#x27;第三列&#x27;&#125;],dataList: [ &#123;&#x27;prop0&#x27;:&#x27;第一行&#x27;,&#x27;prop1&#x27;:&#x27;11&#x27;,&#x27;prop2&#x27;:&#x27;12&#x27;&#125;, &#123;&#x27;prop0&#x27;:&#x27;第二行&#x27;,&#x27;prop1&#x27;:&#x27;21&#x27;,&#x27;prop2&#x27;:&#x27;22&#x27;&#125;,] 整理逻辑如下1234567891011121314head.forEach((element,index) =&gt; &#123; this.itemList.push(&#123; &#x27;label&#x27;:element, &#x27;prop&#x27;: &#x27;prop&#x27;+ index &#125;)&#125;);console.log(this.itemList)body.forEach((element,index) =&gt; &#123; let objectm = &#123;&#125; element.forEach((element1,index1) =&gt; &#123; objectm[&#x27;prop&#x27;+index1] = element1 &#125;); this.dataList.push(objectm)&#125;)","tags":[{"name":"vue","slug":"vue","permalink":"https://saltlike.github.io/tags/vue/"},{"name":"ElementUI","slug":"ElementUI","permalink":"https://saltlike.github.io/tags/ElementUI/"}]},{"title":"es6迭代器","date":"2020-06-02T13:42:23.000Z","path":"2020/06/02/es6迭代器/","text":"es6的集合对象类型Map、Set和数组，有如下迭代器用于搜索它们的内容 entries(): 返回一个包含键值对的迭代器； values(): 返回一个包含集合中的值得迭代器； keys(): 返回一个包含集合中的键的迭代器； 12345678910111213141516171819202122232425262728let colors = [&#x27;red&#x27;,&#x27;green&#x27;,&#x27;blue&#x27;] let testObj = [ &#123;&#x27;id&#x27;:&#x27;id1&#x27;,&#x27;name&#x27;:&#x27;name1&#x27;&#125;, &#123;&#x27;id&#x27;:&#x27;id2&#x27;,&#x27;name&#x27;:&#x27;name2&#x27;&#125;, &#123;&#x27;id&#x27;:&#x27;id3&#x27;,&#x27;name&#x27;:&#x27;name3&#x27;&#125;, ] let testObj1 = &#123;&#x27;id&#x27;:&#x27;id1&#x27;,&#x27;name&#x27;:&#x27;name1&#x27;&#125; for(let entry of colors.entries()) &#123; console.log(entry) // [0,&quot;red&quot;],[1,&quot;green&quot;],[2,&quot;blue&quot;] &#125; for(let entry of testObj.entries()) &#123; console.log(entry) // [0,&#123;&#x27;id&#x27;:&#x27;id1&#x27;,&#x27;name&#x27;:&#x27;name1&#x27;&#125;],[1,&#123;&#x27;id&#x27;:&#x27;id2&#x27;,&#x27;name&#x27;:&#x27;name2&#x27;&#125;],[2,&#123;&#x27;id&#x27;:&#x27;id3&#x27;,&#x27;name&#x27;:&#x27;name3&#x27;&#125;] &#125; for(let values of testObj.values()) &#123; console.log(values) // &#123;&#x27;id&#x27;:&#x27;id1&#x27;,&#x27;name&#x27;:&#x27;name1&#x27;&#125;,&#123;&#x27;id&#x27;:&#x27;id2&#x27;,&#x27;name&#x27;:&#x27;name2&#x27;&#125;,&#123;&#x27;id&#x27;:&#x27;id3&#x27;,&#x27;name&#x27;:&#x27;name3&#x27;&#125; &#125; for(let keys of testObj.keys()) &#123; console.log(keys) // 0,1,2 &#125; for(let keys of Object.keys(testObj1)) &#123; console.log(keys) // id,name &#125; for(let entries of Object.entries(testObj1)) &#123; console.log(entries) // [&quot;id&quot;, &quot;id1&quot;],[&quot;name&quot;, &quot;name1&quot;] &#125; for(let values of Object.values(testObj1)) &#123; console.log(values) // id1,name1 &#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://saltlike.github.io/tags/ES6/"}]},{"title":"map用法","date":"2020-05-21T01:36:01.000Z","path":"2020/05/21/map用法/","text":"以数组对象为例 取数组对象的某个属性和值1234567let arr = [&#123;&#x27;id&#x27;:&#x27;1&#x27;,&#x27;name&#x27;:&#x27;name1&#x27;,&#x27;age&#x27;:&#x27;10&#x27;&#125;,&#123;&#x27;id&#x27;:&#x27;2&#x27;,&#x27;name&#x27;:&#x27;name2&#x27;,&#x27;age&#x27;:&#x27;20&#x27;&#125;,&#123;&#x27;id&#x27;:&#x27;3&#x27;,&#x27;name&#x27;:&#x27;name3&#x27;,&#x27;age&#x27;:&#x27;30&#x27;&#125;]console.log(arr.map(item=&gt;item.name)) //[&quot;name1&quot;, &quot;name2&quot;, &quot;name3&quot;] 取数组对象的多个属性和值12console.log(arr.map((&#123;name,age&#125;) =&gt; (&#123;name,age&#125;))) //[&#123;name: &quot;name1&quot;, age: &quot;10&quot;&#125;,&#123;name: &quot;name2&quot;, age: &quot;20&quot;&#125;,&#123;name: &quot;name3&quot;, age: &quot;30&quot;&#125;]console.log(arr.map((&#123;age&#125;) =&gt; (&#123;age&#125;))) //[&#123;age: &quot;10&quot;&#125;,&#123;age: &quot;20&quot;&#125;,&#123;age: &quot;30&quot;&#125;]","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"javaScript","slug":"javaScript","permalink":"https://saltlike.github.io/tags/javaScript/"}]},{"title":"ES6新特性","date":"2018-04-15T13:04:28.000Z","path":"2018/04/15/ES6新特性/","text":"字符串模板ES6中我们可以使用反引号**&#96;**（Tab上方）来创建字符串，并且可以在字符串中以$(变量名)的形式插入一个变量 12var num = Math.random()console.log(`your num is $(num)`) let和const关键字 let无变量提升12console.log(num) // =&gt; undefinedvar num = 1 12console.log(num) // =&gt; ReferenceErrorlet num = 1 使用var声明的变量会自动提升到当前作用域的顶部，如果声明位置与作用域顶部之间有另一个同名变量，很容易引起错误。使用let声明的变量不会进行变量提升，规避了这个隐患。 var声明的变量提升后虽然在声明语句之前输出为undefined，但这并不代表num变量还没有被声明，此时num变量已经完成声明并分配了相应内存，只是该变量目前的值为undefined 有块级作用域12345&#123; var num = 1 console.log(num) // =&gt; 1&#125;console.log(num) // =&gt; 1 12345&#123; let num = 1 console.log(num) // =&gt; 1&#125;console.lot(num) // =&gt; ReferenceError let声明的变量只能在当前块级作用域中使用 123for(let i = 0, i &lt; 10; i++)&#123;&#125; 禁止重复声明123var dev = truevar dev = falseconsole.log(dev) // =&gt; false 12let dev = truelet dev = false // =&gt; SyntaxError var声明的变量可以重复声明，覆盖原来的值，不会有警告或提示，有隐患。let声明的变量不可以重复声明，否则会直接抛出一个语法错误。 const同上三点 无变量提升 有块级作用域 禁止重复声明 禁止重复赋值12const DEV = trueDEV = false // =&gt; TypeError 根据静态常量的定义可以知道，const声明的常量一经声明便不能再改其值。 必须赋初始值1const DEV // =&gt; SyntaxError const声明的常量既然一经声明，不能再改其值，那声明的时候不赋初始值显然不合理。一个没有值得常量只会浪费内存，没有意义。 箭头操作符&#x3D;&gt;与lambda表达式有异曲同工之妙，它简化了函数的书写，操作符左边为输入的参数，右边是进行的操作和返回的值 inputs &#x3D;&gt; outputsjs中经常用到回调，而一般回调又以匿名函数的形式出现，每次都需要写一个function，很繁琐。引入箭头函数后可以很方便的写回调了。 1234567var arr = [1,2,3,4,5]// beforearr.forEach(function(v)&#123; console.log(v);&#125;)// ES6arr.forEach(v =&gt; console.log(v)) 多个入参时需用括号包裹入参，单个入参时可省略括号 1234var arr = [1,2,3,4,5,6]arr.map((v, k, thisArr) =&gt; &#123; return thisArr.reverse()[k] * v;&#125;) // [6,10,12,12,10,6] 函数上下文中的this 123456789101112131415161718192021// beforevar obj = &#123; arr: [1,2,3,4,5], getMaxPow2: function() &#123; var that = this, getMax = function() &#123; return Math.max.apply(&#123;&#125;, that.arr); &#125;; return Math.pow(getMax(), 2); &#125;&#125;// ES6var obj = &#123; arr: [1,2,3,4,5], getMaxPow2: function() &#123; var getMax = () =&gt; &#123; return Math.max.apply(&#123;&#125;, this.arr); &#125; return Math.pow(getMax(), 2); &#125;&#125; var that &#x3D; this,声明一个临时变量that。在对象或原型链中，我们以前经常会写这样一个临时变量，that或_this，诸如此类，以达到在一个函数内部访问到父级或者祖先级this对象的目的。在箭头函数中，函数体内没有自己的this，默认在其内部调用this时，自动查找其父级上下文的this对象（如果父级也是箭头函数，则会按照作用域链继续向上查找），就不再需要多余的声明一个临时变量了。 注意： 在一些情况下可能需要函数有自己的this，例如DOM事件绑定时事件回调函数中，需要用this来操作当前的DOM，此时就需要使用传统匿名函数而非箭头函数。 在严格模式下，如果箭头函数的上层函数均为箭头函数，那么this对象将不可用。 由于箭头函数没有自己的this对象，所以箭头函数不能当做构造函数。 父级函数 arguments在函数体中有arguments这样一个伪数组对象，该对象中包含该函数所有的入参（显式入参 + 隐式入参）。当函数体中有另一个函数，且该函数为箭头函数时，该箭头函数的函数体中可以直接访问父级函数的arguments对象。 由于箭头函数本身没有arguments对象，所以如果它的上层函数都是箭头函数的话，那么arguments对象将不可用。 小结 共享父级this对象，arguments参数 不能当做构造函数 当箭头函数入参只有一个时可以省略入参括号 当入参多于一个或没有入参时必须有括号 当函数体只有一个return语句时，可以省略函数体的花括号与return关键字 类 &amp; 继承js时面向对象的，es6提供的类实际上只是js原型模式的包装，对象的创建、继承更加直观了，父类方法的调用，实例化，静态方法和构造函数等概念更加形象化。类的定义 12345678910111213141516171819202122232425262728/* 类不会被提升 */let puppy = new Animal(&#x27;puppy&#x27;); // ReferenceErrorclass Animal &#123; constructor(name) &#123; this.name = name; &#125; sleep() &#123; console.log(`the $&#123;this.name&#125; is sleeping...`); &#125; static type() &#123; console.log(`this is an Animal class.`); &#125;&#125;let puppy = new Animal(&#x27;puppy&#x27;);puppy.sleep(); // the puppy is sleeping.../*实例化后无法访问静态方法*/puppy.type(); // TypeErrorAnimal.type(); // this is an Animal class./*实例化前无法访问动态方法*/Animal.sleep(); // TypeError/*类不能重复定义*/class Animal() &#123;&#125; // SyntaxError 类的定义中没有要求类名的大小写，鉴于代码规范，推荐类名首字母大写 类定义中有一特殊方法constructor()，该方法名固定，表示该类的构造函数（方法），在类的实例化过程中会被调用，new Animal(‘puppy’) 类中无法像对象一样使用prop: value或者prop &#x3D; value 的形式定义一个类的属性，只能在类的构造方法或其他方法中使用this.prop &#x3D; value的形式为类添加属性。 123456789101112// beforefunction Animal(name) &#123; this.name = name;&#125;Animal.prototype = &#123; sleep: function() &#123; console.log(&#x27;the&#x27; + this.name + &#x27;is sleeping...&#x27;); &#125;&#125;;Animal.type = function() &#123; console.log(&#x27;this is an Animal class.&#x27;);&#125; 类的继承 123456789101112131415161718192021class Programmer extends Animal &#123; constructor (name) &#123; /*在super方法之前this不可用*/ console.log(this); // ReferenceError super(name); console.log(this) &#125; program() &#123; console.log(&quot;I&#x27;m coding...&quot;); &#125; sleep() &#123; console.log(&#x27;save all files.&#x27;); console.log(&#x27;get into bed&#x27;); super.sleep(); &#125;&#125;let coder = new Programmer(&#x27;coder&#x27;);coder.program(); // I&#x27;m coding...coder.sleep(); // save all files. get into bed. the coder is sleeping. 使用class定义类Programmer，使用extends关键字继承类Animal 若子类有构造方法，那么子类构造方法中使用this对象之前必须使用super()方法运行父类的构造方法以对父类进行初始化。 在子类方法中可以使用super对象来调用父类上的方法。 小结 本质为对原型链的二次包装 类没有提升 不能使用字面量定义属性 动态继承类的构造方法中super优先于this 模块将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入方式在其他地方使用。es6正式推出模块化规范 内联导出12345678910111213export const DEV = true;export function example() &#123; //...&#125;export class expClass &#123; //...&#125;export let obj = &#123; DEV, example, expClass, //...&#125; 使用export关键字，后面紧跟声明关键字（let、function等）声明一个导出对象，这种声明并同时导出的方式称为内联导出。未被导出的内容（变量、函数、类等）由于独立代码块的原因，将仅供模块内部使用（类似闭包)。 对象导出1234567891011121314151617// module example.jsconst DEV = true;function example() &#123; //...&#125;class expClass &#123; //...&#125;let obj = &#123; DEV, example, expClass, //...&#125;// module example.jsexport &#123;DEV,example,expClass,obj&#125;export &#123;DEV,example as exp,expClass,obj&#125; 我们可以像写普通js文件一样写主要的功能逻辑，最好通过export集中导出。导出时使用as关键字改变导出对象的名称。 默认导出123export default &#123;DEV,example as exp,expClass,obj&#125;;export default obj;export default const DEV = true; 在export关键字后接default来设置模块的默认导出对象，一个模块只能有一个默认导出。 模块导入1234import example from &#x27;./example.js&#x27;;import default as example from &#x27;./example.js&#x27;import * as exp from &#x27;./example.js&#x27;// 使用通配符*配合as关键字一次性导出模块中所有内容，最终导入的内容放在exp对象中 小结 封闭的代码块，每个模块都有自己完全独立的代码块，跟作用域类似，但更加封闭。 无限制导出，一个模块理论上可以导出无数个变量、函数、对象属性、对象方法、类。但是要合理控制代码颗粒度。 严格模式下运行，模块默认在（’use strick’）下运行","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://saltlike.github.io/tags/ES6/"}]},{"title":"前端小结","date":"2017-12-07T05:24:38.000Z","path":"2017/12/07/前端小结/","text":"ES6新特性PromisePromise处理异步代码的代码可读性比回调机制要好；问题是如果没有处理Promise的reject，会导致错误被丢进黑洞。 面试问题跨域和前端解决 跨域源于浏览器的同源策略限制，一级域名、二级域名、端口有一个不同，都属于跨域行为；前端解决跨域方法不多：Chrome可借助CORS插件代理同域请求到跨域接口；实际编码中可使用CORS(Cross-Origin-Resource-Sharin)和JSONP;JSONP的原理是利用 &lt;script&gt; 标签允许跨域资源请求的漏洞实现的，它使用&lt;script&gt;发送跨域请求，并使用一个callback参数将请求信息传递给服务器，服务器返回一个JS脚本包含我们指定的callback函数，然后我们执行callback即可获得服务器返回的内容；由于局限于&lt;script&gt;，所以JSONP只能发送GET请求；还有document.domain 或window.name等一些解决方案； web前端性能优化一般说来，web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有浏览器访问，使用反向代理、CDN等； 浏览器访问优化减少http请求，合理设置http缓存减少http的主要手段有合并CSS、合并JavaScript、合并图片恰当的缓存可以大大减少http请求：很少变化的图片资源可以直接通过http header中的Expires设置一个很长的过期头；变化不频繁又可能会变得资源可以使用Last-Modifed来做请求验证 使用浏览器缓存CSS Sprites合并CSS图片，减少请求数； 应用压缩压缩HTML、CSS、JS文件 CSS放在页面最上部，JS放在页面最下面JS代码优化1、DOM操作要考虑浏览器的Reflow和Repaint，这些需要消耗资源。2、避免用with、eval、Function 消耗资源、效率低、速度慢；3、减少作用域链查找，减少闭包使用；4、使用字符串拼接 CSS选择符优化异步请求CallbackCDN加速CDN缓存的一般是静态资源，如图片、文件、CSS、script脚本、静态网页等 反向代理同时可以实现负载均衡功能","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"测试","date":"2017-12-03T10:16:02.000Z","path":"2017/12/03/测试/","text":"测试","tags":[]},{"title":"前端知识点","date":"2017-11-08T07:46:28.000Z","path":"2017/11/08/前端知识点/","text":"块状元素与内联元素 内联元素转化为块状元素： 1display: block; 内联元素不能设置宽和高，只能变成block,或inline-block才可以;","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"使用vue.js搭建项目","date":"2017-11-04T01:25:22.000Z","path":"2017/11/04/使用vue-js搭建项目/","text":"我的window10ssh hexo hhh","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"vue","permalink":"https://saltlike.github.io/tags/vue/"}]},{"title":"搭建多终端同步的github + hexo静态博客","date":"2017-11-02T02:39:02.000Z","path":"2017/11/02/搭建多终端同步的github-hexo静态博客/","text":"前提条件拥有github账号本地终端安装git安装node.js github上创建个人主页新建仓库，名字与自己的用户名一致 从远程拉取仓库到本地git clone 仓库地址 本地 hexo 配置（核心）创建 hexo 分支1git checkout -b hexo 创建hexo分支并将其作为默认分支 备份原始的 .git 文件ll -a 查看目录下所有文件，发现有一个 .git 文件夹,该文件夹在后面push到hexo分支会有用，所以先备份一下在最后恢复； 安装hexo并初始化安装时要清空根目录文件夹（.git 文件夹已备份）依次执行如下命令： 1234npm install hexo //全局安装hexo的可以省略hexo initnpm installnpm install hexo-deployer-git --save 再恢复已经备份的 .git 文件夹，以免影响以后的push； 修改 _config.yml 中的deploy参数修改type 、repository、branch参数 将hexo分支push到远程hexo分支上执行： 123git add .git commit -m &quot;xxx&quot;git push origin hexo 此时hexo配置文件都被push到了远程hexo分支上 生成静态页面并部署执行hexo g -d将静态页面部署到master分支上。此时repo上有两个分支hexo（存储配置文件）和master（存储静态页面）；输入url即可看到博客页面。 日常上传博客流程在本地对博客进行修改（添加新博文，修改样式等）后，可通过以下流程管理。 依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）； 执行hexo g -d发布网站到master分支上。1以后的操作全都在hexo分支上执行，不需要切换到master分支。 其他终端上传博客如果你想在另一个电脑上上传你自己的博客，那么你只需要如下做即可： 从repo仓库上将项目代码clone到本地。 此时本地只有master分支，切换到hexo分支。1git checkout -b hexo origin/hexo 此时查看拉下来的repo有没有.deploy_git文件夹，如果有的话，删除并重新安装本地的hexo-deployer。 12rm -r .deploy_gitnpm install hexo-deployer-git --save 搞定，之后按照步骤5即可完成上传。 git clone 后，直接npm install,然后 add，commit,push ,hexo g -d; 页面空白问题1、看看主题文件有没有加载上； hexo调试模式启动 Hexo 本地站点，并开启调试模式，命令： 1hexo s --debug","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://saltlike.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://saltlike.github.io/tags/git/"}]},{"title":"浏览器 css reset 方法","date":"2017-10-31T06:57:33.000Z","path":"2017/10/31/浏览器-css-reset-方法/","text":"css reset 定义即重设浏览器样式；在各种浏览器中，都会对css的选择器默认一些数值（例如当h1没有被设置数值时，显示一定大小）；但并不是所有浏览器都使用一样的数值，所以有了css reset，以让网页的样式在各浏览器中表现一致。 css reset 方法简单方法1* &#123; padding: 0; margin: 0; border: 0; &#125; 简单、安全、强大，让所有选择器的padding、margin、border都设置成0；缺点是占用资源；对于小型的网站，用这个并不会带来大的资源浪费；但对于架构大的网站，则需要有选择地进行css重设，以减少资源浪费； Yahoo CSS Reset12345678910111213141516171819202122232425262728293031323334353637383940body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,form,fieldset,input,textarea,p,blockquote,th,td &#123; padding: 0; margin: 0; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125; fieldset,img &#123; border: 0; &#125; address,caption,cite,code,dfn,em,strong,th,var &#123; font-weight: normal; font-style: normal; &#125; ol,ul &#123; list-style: none; &#125; caption,th&#123; text-align: left; &#125; h1,h2,h3,h4,h5,h6 &#123; font-weight: normal; font-size: 100%; &#125; q:before,q:after &#123; content:”; &#125; abbr,acronym &#123; border: 0; &#125; Ateneu Popular CSS Reset123456789101112131415161718192021222324252627282930313233343536373839404142434445464748html, body, div, span, applet, object, iframe, h1, h2, h3,h4, h5, h6, p, blockquote, pre, a, abbr, acronym,address, big, cite, code, del, dfn, em, font, img, ins,kbd, q, s, samp, small, strike, strong, sub, sup, tt,var, dl, dt, dd, ol, ul, li, fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td &#123; margin: 0; padding: 0; border: 0; outline: 0; font-weight: inherit; font-style: inherit; font-size: 100%; font-family: inherit; vertical-align: baseline; &#125; :focus &#123; outline: 0;&#125; a, a:link, a:visited, a:hover, a:active&#123; text-decoration:none&#125; table &#123; border-collapse: separate;border-spacing: 0;&#125; th, td &#123; text-align: left; font-weight: normal;&#125; img, iframe &#123; border: none; text-decoration:none;&#125; ol, ul &#123; list-style: none;&#125; input, textarea, select, button &#123; font-size: 100%;font-family: inherit;&#125; select &#123; margin: inherit;&#125; hr &#123; margin: 0;padding: 0;border: 0;color: #000;background-color: #000;height: 1px&#125;","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"css","permalink":"https://saltlike.github.io/tags/css/"}]},{"title":"hexo使用","date":"2017-10-31T01:13:08.000Z","path":"2017/10/31/hexo使用/","text":"hexo使用方法每次部署步骤，分三步：hexo cleanhexo generatehexo deploy 常用命令：hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本","tags":[{"name":"前端","slug":"前端","permalink":"https://saltlike.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"hexo","slug":"hexo","permalink":"https://saltlike.github.io/tags/hexo/"}]}]